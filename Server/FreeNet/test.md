### 네트워크 기본 모듈 작성 
네트워크 통신을 하기 위한 기반 코드를 작성해 보겠습니다.
강좌 목표에 집중하기 위해서 이 강좌에서는 TCP 소켓만 지원해보겠습니다.

CNetworkService 클래스에 네트워크 통신에 필요한 기반이 될 코드들을 넣어볼것입니다.
일단 멤버 변수들 부터 알아보도록 하겠습니다.



클라이언트의 접속을 받아들이는 Listener 객체가 선언되어 있습니다.
소켓 프로그래밍을 배워 보신 분이라면 bine -> listen->accept 순서를 알고 계실겁니다.
.Net 이 최신 기술이긴 하지만 TCP와 관련된 부분은 옛부터 내려오고 있는 흐름을 거의 그대로 따라갑니다.
다른 언어로 구현한다고 해도 이 부분은 크게 변하지 않죠.

그 다음 줄을 보면 생소한 객체가 보일겁니다.
SocketAsyncEventArgs 라는 클래스는 .Net 비동기 소켓에서 사용하는 개념으로
비동기 소켓 매소드를 호출할 때 항상 필요한 객체입니다.
이전에 사용하던 Begin~End 계열의 API 를 쓸 때보다 더 발전된 부분이라고 하는데요.
매번 IAsyncResult를 생성하지 않고 저렇게 풀링하여 사용할 수 있기 때문에 메모리 재사용이 가능한것이 장점입니다.
MSDN의 문서중에 객체를 풀링하여 쓰는것이 기존 native c++ 에서 하는 풀링만큼의
효율을 가져오지 않을 수 있다고 나와있습니다.

여기서는 풀링사용 했습니다.
어차피 서버가 살아있느 동안에는 계속 사용할 메모리기 때문에 풀링이 좋다고 생각!

그 다음 중에 BufferManager가 보입니다.
이름 에서 알 수 있듯이, 데이터 송 수신할 때 사용할 버퍼를 관리하는 매니저 객체 입니다.
소켓에 관련된 책을 보면 송 수신 버퍼라는 얘기를 자주 듣게 됩니다.
TCP 데이터를 보내고 받을 때 소켓마다 버퍼라는 것이 할당됩니다.
이건 OS딴에서 구현되어 있는 부분이라 신경쓸 필요 없습니다.

이 소켓 버퍼로 부터 메시지를 복사해 오고 밀어넣는 작업을 할 때 사용할 버퍼를 설정해주면 됩니다.
이 버퍼 역시 네트워크 통신이 지속되는 동안 계속 메모리를 사용하겠죠
따라서 이것도 풀링하여 메모리를 재사용 할 수 있도록 하겠습니다.



Listen 처리 코드의 일부분 입니다.
CListener 클래스를 선언했습니데, Listener 를 여러개 두는 구조로 설계하였기 때문입니다.

다른 서버 간 통신을 위해서 다른 서버의 접속을 받아들이는 Listener등 여러 Listener가 존재 할 수 있습니다.



Socket